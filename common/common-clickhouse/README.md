# 前言

## 行式数据库

在传统的行式数据库系统中，数据按如下顺序存储：

| Row | WatchID     | JavaEnable | Title              | GoodEvent | EventTime           |
|-----|-------------|------------|--------------------|-----------|---------------------|
| #0  | 89354350662 | 1          | Investor Relations | 1         | 2016-05-18 05:19:20 |
| #1  | 90329509958 | 0          | Contact us         | 1         | 2016-05-18 08:10:20 |
| #2  | 89953706054 | 1          | Mission            | 1         | 2016-05-18 07:38:00 |
| #N  | ...         | ...        | ...                | ...       | ...                 |

处于同一行中的数据总是被物理的存储在一起。

```
(89354350662, 1, nvestor Relations, 1, 2016-05-18 05:19:20)
(90329509958, 0, Contact us, 1, 2016-05-18 08:10:20)
(89953706054, 1, Mission, 1, 2016-05-18 07:38:00)
...
```

常见的行式数据库系统有：MySQL、Postgres和MS SQL Server。

## 列式数据库

在列式数据库系统中，数据按如下的顺序存储：

| Row:        | #0                  | #1                  | #2                  | #N  |
|-------------|---------------------|---------------------|---------------------|-----|
| WatchID:    | 89354350662         | 90329509958         | 89953706054         | ... |
| JavaEnable: | 1                   | 0                   | 1                   | ... |
| Title:      | Investor Relations  | Contact us          | Mission             | ... |
| GoodEvent:  | 1                   | 1                   | 1                   | ... |
| EventTime:  | 2016-05-18 05:19:20 | 2016-05-18 08:10:20 | 2016-05-18 07:38:00 | ... |

这些示例只显示了数据的排列顺序。来自不同列的值被单独存储，来自同一列的数据被存储在一起。

```
WatchID:   [89354350662, 90329509958, 89953706054, ...]
JavaEnable:[1, 0, 1, ...]
Title:     [Investor Relations, Contact us, Mission, ...]
GoodEvent: [1, 1, 1, ...]
EventTime: [2016-05-18 05:19:20, 2016-05-18 08:10:20, 2016-05-18 07:38:00, ...]
```

列式存储的优点：

- 高效的压缩：相同类型的数据存储在一起，可以更高效地应用压缩算法，减少存储空间。
- 快速读取：查询某些列时，系统只需要读取相关列的数据，而不必扫描整个表。这对于涉及大量数据的大规模分析查询尤为有效。

例如，如果你只想查询所有人的 Age 列，在行式存储中，每行的数据都需要读取和解析，即使只需要 Age 一列。而在列式存储中，只需读取存储 Age 列的数据，这会显著提高查询性能。

将来自不同列的数据分开存储，而同一列的数据则连续存储在一起。这种列式存储方式对大规模数据分析尤其有利，因为它能带来更高效的数据压缩和快速的查询性能。

常见的列式数据库有： ClickHouse、Vertica、 Paraccel (Actian Matrix，Amazon Redshift)、 Sybase IQ、 Exasol、 Infobright、 InfiniDB、 MonetDB (VectorWise， Actian Vector)、 LucidDB、 SAP HANA、 Google Dremel、 Google PowerDrill、 Druid、 kdb+。

不同的数据存储方式适用不同的业务场景，数据访问的场景包括：进行了何种查询、多久查询一次以及各类查询的比例；每种类型的查询(行、列和字节)读取多少数据；读取数据和更新之间的关系；使用的数据集大小以及如何使用本地的数据集；是否使用事务,以及它们是如何进行隔离的；数据的复制机制与数据的完整性要求；每种类型的查询要求的延迟与吞吐量等等。

系统负载越高，依据使用场景进行定制化就越重要，并且定制将会变的越精细。没有一个系统能够同时适用所有不同的业务场景。如果系统适用于广泛的场景，在负载高的情况下，要兼顾所有的场景，那么将不得不做出选择。是要平衡还是要效率？


## OLAP场景的关键特征

- 绝大多数是读请求
- 数据以相当大的批次(> 1000行)更新，而不是单行更新;或者根本没有更新。
- 已添加到数据库的数据不能修改。
- 对于读取，从数据库中提取相当多的行，但只提取列的一小部分。
- 宽表，即每个表包含着大量的列
- 查询相对较少(通常每台服务器每秒查询数百次或更少)
- 对于简单查询，允许延迟大约50毫秒
- 列中的数据相对较小：数字和短字符串(例如，每个URL 60个字节)
- 处理单个查询时需要高吞吐量(每台服务器每秒可达数十亿行)
- 事务不是必须的
- 对数据一致性要求低
- 每个查询有一个大表。除了他以外，其他的都很小。
- 查询结果明显小于源数据。换句话说，数据经过过滤或聚合，因此结果适合于单个服务器的RAM中

很容易可以看出，OLAP场景与其他通常业务场景(例如,OLTP或K/V)有很大的不同， 因此想要使用OLTP或Key-Value数据库去高效的处理分析查询场景，并不是非常完美的适用方案。例如，使用OLAP数据库去处理分析请求通常要优于使用MongoDB或Redis去处理分析请求。

## 列式数据库更适合OLAP场景的原因

列式数据库更适合于OLAP场景(对于大多数查询而言，处理速度至少提高了100倍)，下面详细解释了原因(通过图片更有利于直观理解)：

### 行式

![column](doc/image/row.gif)

### 列式

![column](doc/image/column.gif)

看到差别了么？下面将详细介绍为什么会发生这种情况。

### 输入/输出

- 针对分析类查询，通常只需要读取表的一小部分列。在列式数据库中你可以只读取你需要的数据。例如，如果只需要读取100列中的5列，这将帮助你最少减少20倍的I/O消耗。
- 由于数据总是打包成批量读取的，所以压缩是非常容易的。同时数据按列分别存储这也更容易压缩。这进一步降低了I/O的体积。
- 由于I/O的降低，这将帮助更多的数据被系统缓存。

例如，查询«统计每个广告平台的记录数量»需要读取«广告平台ID»这一列，它在未压缩的情况下需要1个字节进行存储。如果大部分流量不是来自广告平台，那么这一列至少可以以十倍的压缩率被压缩。当采用快速压缩算法，它的解压速度最少在十亿字节(未压缩数据)每秒。换句话说，这个查询可以在单个服务器上以每秒大约几十亿行的速度进行处理。这实际上是当前实现的速度。

### CPU

由于执行一个查询需要处理大量的行，因此在整个向量上执行所有操作将比在每一行上执行所有操作更加高效。同时这将有助于实现一个几乎没有调用成本的查询引擎。如果你不这样做，使用任何一个机械硬盘，查询引擎都不可避免的停止CPU进行等待。所以，在数据按列存储并且按列执行是很有意义的。

有两种方法可以做到这一点：

- 向量引擎：所有的操作都是为向量而不是为单个值编写的。这意味着多个操作之间的不再需要频繁的调用，并且调用的成本基本可以忽略不计。操作代码包含一个优化的内部循环。
- 代码生成：生成一段代码，包含查询中的所有操作。

这是不应该在一个通用数据库中实现的，因为这在运行简单查询时是没有意义的。但是也有例外，例如，MemSQL使用代码生成来减少处理SQL查询的延迟(只是为了比较，分析型数据库通常需要优化的是吞吐而不是延迟)。

请注意，为了提高CPU效率，查询语言必须是声明型的(SQL或MDX)， 或者至少一个向量(J，K)。 查询应该只包含隐式循环，允许进行优化。


# 简介

[官网](https://clickhouse.com/docs/zh)

[GitHub](https://github.com/ClickHouse/ClickHouse)

ClickHouse 是一个用于联机分析（OLAP）的列式数据库管理系统（DBMS）。

优点

- 高性能分析：ClickHouse 专为在线分析处理（OLAP）而设计，能够在大规模数据集上提供非常高效的查询性能。
- 列式存储：数据按列存储，使得对单个或少数列的查询和聚合操作非常迅速。
- 实时数据插入：支持实时数据插入，并能快速地进行复杂查询。-- 实时分析
- 分布式架构：天然支持分布式存储和计算，可以轻松扩展到处理大规模数据。

缺点：

- 不适合事务处理：ClickHouse 不是为在线事务处理（OLTP）设计的，缺乏事务处理的ACID特性。
- 学习曲线陡峭：对于没有列式存储使用经验的用户，可能需要一定的学习和适应时间。
- 有限的更新和删除能力：虽然在最近的版本中有所改进，但更新和删除操作仍然相对较慢。

适用场景：

- 大规模数据分析
- 实时数据监控和报告
- 时间序列数据处理

# 性能

## 单个大查询的吞吐量

吞吐量可以使用每秒处理的行数或每秒处理的字节数来衡量。如果数据被放置在page cache中，则一个不太复杂的查询在单个服务器上大约能够以2-10GB／s（未压缩）的速度进行处理（对于简单的查询，速度可以达到30GB／s）。如果数据没有在page cache中的话，那么速度将取决于你的磁盘系统和数据的压缩率。例如，如果一个磁盘允许以400MB／s的速度读取数据，并且数据压缩率是3，则数据的处理速度为1.2GB/s。这意味着，如果你是在提取一个10字节的列，那么它的处理速度大约是1-2亿行每秒。

对于分布式处理，处理速度几乎是线性扩展的，但这受限于聚合或排序的结果不是那么大的情况下。

## 处理短查询的延迟时间

如果一个查询使用主键并且没有太多行(几十万)进行处理，并且没有查询太多的列，那么在数据被page cache缓存的情况下，它的延迟应该小于50毫秒(在最佳的情况下应该小于10毫秒)。 否则，延迟取决于数据的查找次数。如果你当前使用的是HDD，在数据没有加载的情况下，查询所需要的延迟可以通过以下公式计算得知： 查找时间（10 ms） * 查询的列的数量 * 查询的数据块的数量。

## 处理大量短查询的吞吐量

在相同的情况下，ClickHouse可以在单个服务器上每秒处理数百个查询（在最佳的情况下最多可以处理数千个）。但是由于这不适用于分析型场景。因此我们建议每秒最多查询100次。

## 数据的写入性能

我们建议每次写入不少于1000行的批量写入，或每秒不超过一个写入请求。当使用tab-separated格式将一份数据写入到MergeTree表中时，写入速度大约为50到200MB/s。如果您写入的数据每行为1Kb，那么写入的速度为50，000到200，000行每秒。如果您的行更小，那么写入速度将更高。为了提高写入性能，您可以使用多个INSERT进行并行写入，这将带来线性的性能提升。


